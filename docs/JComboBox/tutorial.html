
<!doctype html public "-//w3c//dtd html 3.2//en">
<html>
<head>
  <title>Exploring The Perl/Tk JComboBox - A Tutorial</title>
  <link rel="stylesheet" type="text/css" href="../ptkdocs.css">
  <meta name="Date" content="20 Apr 2001">
  <meta name="Author" content="Rob Seegel">
  <meta name="keywords" content="Tk::JComboBox, JComboBox, ComboBox, 
      Pulldown, Tutorial, Perl/Tk, Tk">
  <meta name="description" content="Tutorial describing usage of the Tk::JComboBox
      widget for Perl/Tk">
 </head>
<body background="../bg.gif">

<table CELLPADDING=4 WIDTH="100%" ALIGN=center>
<tr valign=middle>
  <td CLASS="header" colspan><font size="+2">&nbsp;Exploring Tk::JComboBox - A Tutorial</font></TD>
  <th width=10%" class='subheader'>Document Info</th>
  </tr>
<tr>
  <td><a  href="../JComboBox.html">Class Reference</a> <b>|</b> 
         <a href=""></a>FAQ <b>|</b> 
         <a href="change.html">Changes/Bug fixes</a>
  </td>
  <td valign="top" width ="30%" height='100%' rowspan=2>
    <table width="100%" >
      <tr ><th align=right>Date:</th><td>20 Apr 2001</td></tr>
      <tr><th align=right>Author:</th><td>Rob Seegel</td></tr>
      <tr><th align=right>Package:</b></td><td>JComboBox</td></tr>
    </table>      
  </td>
</tr>

<tr>
  <td>
<UL>
    <li><A HREF="#introduction">What is it and what is it good for?</a></li>
    <li><A HREF="#modes">Two modes of operation</a></li>
    <ul>
      <li><A HREF="#readonly">Read only</a></li>
      <li><A HREF="#editable">Editable</a></li>
    </ul>
    <li><A HREF="#basics">Typical list element tasks</a></li>
    <ul>
      <li><A HREF="#add_elements">Adding</a></li>
      <li><A HREF="#select_elements">Selecting</a></li>
      <li><a href="#remove_elements">Removing</a></li>
    </ul>  
    <li><a href="#additional">Additional Functionality</a></li>
    <ul>
      <li><a href="#getitem">Getting list items</a></li>
      <li><a href="#validation">Validation</a></li>
      <li><a href="#listhighlight">List highlighting</a></li>
    </ul>
    <li><a href="#related_docs">Related Documents</a></li>
</ul>
  </td>
</tr>
</table>
<hr>

<a name="introduction"></a>
<h3>What is it and what is it good for?</h3>
<p class="pMargin">
JComboBox is yet another combo box implementation  for
use with the Perl/Tk Toolkit.  A combo box is basically a widget that can
activate a dropdown listbox with a number of items. After an item is
selected, the listbox disappears and that item appears on the widget.
This is a space-saving alternative to having a full list in the interface, or 
having a very long panel of radio buttons.
</p>

<p class="pMargin">
This implementation is named for the JComboBox used
with the Java Swing classes, and those familiar with that component should
have no problem using this because the similarities go beyond the name
and extend to the method names, and general behavior.  When compared to
other similar Perl/Tk widgets, JComboBox is probably the most bloated or to 
put it another way, feature-rich.  It has a slightly larger overhead associated 
with it than any of the others.  Simply put, there is more code to support the
extra options and methods it offers. In applications I have used it in, I've found that the 
cost is negligible and that the benefits outweigh the cost, but since requirements
and constraints vary, it's probably best to determine this for yourself.
</p>

<a name="modes"></a><h3>Two modes of operation</h3>
<p class="pMargin">
Like the Java Component, this widget has two modes of operation: uneditable
and editable.  To better distinguish the two modes, for this widget the uneditable 
mode is called <b>readonly</b>.  Each mode has a separate visual appearance, and
widget options may have slightly different effects depending on the mode.
</p>

<a name="readonly"></a><h3>Read Only ( readonly )</h3>
<div class="pMargin">
<table width="90%">
  <tr valign='top'>
    <td  width="60%">
In this mode, the widget looks like a button, though it is actually most like an
Optionmenu widget.  Pressing anywhere on the face of this button will cause the drop-down 
listbox to appear. The two main visual differences between the two is that JComboBox
can have a scrollbar, and Optionmenu uses a slightly different symbol instead of an arrow.
This is the default mode for JComboBox.
    </td>
   <th><img src="jcb_ro.gif" width="112" height="142" alt="JComboBox in "readonly" mode"></th>
   </tr>
</table>
</div>
<p>The JComboBox in the image above, was created using the following code:</p>
<pre>
use Tk;
use Tk::JComboBox;

my $mw = MainWindow->new();
my $jcb = $mw->JComboBox(
  -relief => 'groove',
  -popuprelief => 'groove',
  -highlightthickness => 0,
  -choices => [qw/Black Blue Green Purple Red Yellow/]
)->pack;

MainLoop;</pre>

<a name="editable"></a>
<br>
<h3>Editable</h3>
<div class="pMargin">
<table width="90%">
  <tr valign='top'>
    <td  width="60%">
In this mode, the widget resembles an entry widget with a button to the right
of it. The entry allows user to provide a value that might not appear within
the list. Optionally, the entry could be used to <a href="#validate">validate</a>
an entry. Visually, this mode resembles the typical combo box as seen on 
Win32 systems. It also resembles ComboEntry and looks somewhat like 
BrowseEntry.
    </td>
   <th><img src="jcb_edit.gif" width="111" height="142" alt="JComboBox in editable mode"></th>
   </tr>
</table>
</div>

<p>The JComboBox in the image above, was created using the following code:</p>

<pre>
use Tk;
use Tk::JComboBox;

my $mw = MainWindow->new();
my $jcb = $mw->JComboBox(
  -relief => 'sunken',
  -mode => 'editable',
  -listbackground => 'white',
  -popuprelief => 'groove',
  -highlightthickness => 0,
  -choices => [qw/Black Blue Green Purple Red Yellow/]
)->pack;

MainLoop;</pre>

<a name="basics"></a>
<br>
<h3>Typical list element tasks</h3>
<p class="pMargin">
The examples above showed how someone might populate a JComboBox
statically. This is, set the list of elements by setting one operation. There are
times when it might be preferrable to add a single list element, remove one or 
even select one programmatically. All these things can be done easily, and
usually in a variety of different ways. Before going any further, it is useful to
know that there are three pieces of information that can be associated with 
each list element.
</p>
<ul>
  <li><i>index</i> - this is an integer value that denotes the list element's position
  within the popup listbox. The first element in the list is index 0. Refer to the Tk::Listbox documentation for information on other non-numeric index values</li>
  <li><i>name</i> - or displayed value. This is a string of text that represents the list
  element in the listbox and is displayed on the JComboBox when the list
  elment is selected.</li>
  <li><i>value</i> - this is an additional value that can be stored for each element.
   When not specified, the name doubles as the value for the list element. This is similar
   to the html form element <i>&lt;option&gt;</i>, which can have a name and a value attribute.</li>
</ul>

<a name="add_elements"></a><h3>Adding items</h3>
<p>
<p class="pMargin">
The two examples above showed how a list could be populated by assigning an 
array reference to the <a href='../JComboBox.html#choices'>-choices</a> ( or it's alias, 
<i>-listitems</i> ) option. In both of these examples, the <i>name</i> 
for each element was set, but about the <i>value</i>? What if you wanted to 
store an RGB value for each element, but didn't necessary want to show that to 
the user? You could do something like this:
</p>
<pre>

  -choices => [
     { -name => 'Black',  -value => '#000000' },
     { -name => 'Blue',   -value => '#0000ff' },
     { -name => 'Green',  -value => '#008000' },
     { -name => 'Purple', -value => '#8000ff' },
     { -name => 'Red',    -value => '#ff0000' },
     { -name => 'Yellow', -value => '#ffff00' }
  ]</pre>

<p class="pMargin">
You could also use both hash references and scalars if you wished, like this:
</p>
<pre>
  -choices => [
     'Black',
     { -name => 'Blue',   -value => '#0000ff' },
     'Green',
     'Purple',
     'Red',
     { -name => 'Yellow', -value => '#ffff00' }
  ]</pre>

<p class="pMargin">
Although <i>-choices</i> can be used to populate or repopulate the list, 
there are times when it's convenient to insert or add a single element
to the list without having to reset all the other elements. There are two methods
that provide this functionality: <a href='../JComboBox.html#addItem'>addItem</a> or <a href='../JComboBox.html#addItem'>insertItemAt</a>. Both are very similar.</p>

<p class="pMargin">
The following inserts a new item into the list:
</p>

 <pre>
  ## If this line is added to the above examples, then it will add an
  ## an item called 'Orange' after 'Red', and before 'Yellow'.

  $jcb->insertItemAt( 5, 'Orange', -value => '#ff8000' );</pre>

<p class="pMargin">
The following code snippet appends an entry to the end of the list:
</p>
<pre>
  $jcb->addItem( 'Orange', -value => '#ff8000' );</pre>
 
<a name="select_elements"></a>
<br>
<h3>Selecting items</h3>
<p class="pMargin">
Often, it is desirable to have a default item selected, so that
when the widget is created, one of the items from the list
will appear within the JComboBox's label or entry ( depending on
mode ). There are several ways to do this. An item can be
marked as selected from within the -choices option, it can be
set from within, or it can be selected by one of two method calls.
</p>

<p class="pMargin">From within -choices:</p>
<pre>
  ## Set Black as the default selected item. You can 
  ## set more than one item in the list as selected, but only
  ## the last item marked as selected actually is.

  -choices => [
     { -name => 'Black',  -value => '#000000', -selected => 1 },
     { -name => 'Blue',   -value => '#0000ff' },
     { -name => 'Green',  -value => '#008000' },
     { -name => 'Purple', -value => '#8000ff' },
     { -name => 'Red',    -value => '#ff0000' },
     { -name => 'Yellow', -value => '#ffff00' }
  ]</pre>

<br>
<p class="pMargin">From either the <i>addItem</i> or <i>insertItemAt</i> methods:
</p>
<pre>
  $jcb->insertItemAt( 5, 'Orange', -value => '#ff8000', -selected => 1 );

  $jcb->addItem( 'Orange', -value => '#ff8000', -selected => 1 );</pre>

<br>
<p class="pMargin">Or from one of two other methods: <a 
  href='../JComboBox.html#setSelectedIndex'>setSelectedIndex</a> or <a 
  href='../JComboBox.html#setSelected'>setSelected</a>.
</p>

<p class="pMargin">
<i>setSelectedIndex</i> is simple to use:
</p>
<pre>
  ## Selects the first item in the list
  $jcb->setSelectedIndex( 0 );</pre>

<br>
<p class="pMargin">
<i>setSelected</i> is a bit more complex. For this method, a pattern is passed
as a parameter and the list is searched starting at index 0, until the entire list 
has been searched or until the first match has been found. But what gets compared,
and how does it get compared? That depends on other parameters passed to the
method. It has two optional parameters: <i>-type</i> and <i>-mode</i>
</p>

<p class="pMargin">
The <i>-type</i> option describes the list item type. That is which part of the
item is being searched. The type has two possible values: <b>name</b>, the default,
 and <b>value</b>. 
</p>

<p class="pMargin">
The <i>-mode</i> option describes the search mode. Currently there are three:
<b>exact</b>,  <b>usecase</b>, and <b>ignorecase</b>.  The pattern must 
exactly match the entire name or value, from beginning to end when the mode is set
to exact. Modes usecase and  ignorecase match the beginnings of strings ( The 
specified pattern need not be complete like exact ). The only difference is that 
usecase is case senstive and ignorecase is not.
</p> 

<p class="pMargin">A few examples:</p>
<pre>
  use Tk; 
  use Tk::JComboBox;

  my $mw = MainWindow->new();
  my $jcb = $mw->JComboBox(
    -relief => 'groove',
    -popuprelief => 'groove',
    -highlightthickness => 0,
    -choices => [
      { -name => 'Black', -value => 1},
      { -name => 'Blue',  -value => 2},
      { -name => 'Green', -value => 3},
      { -name => 'Purple' -value => 4},
      'Red',
      { -name => 'Yellow' -value => 5 }]
  )->pack;

  ## Selects the last element, 'Yellow' using defaults for -type and -mode
  $jcb->setSelected( 'Yellow' );	

  ## Selects the list item 'Purple', using default for -mode
  $jcb->setSelected( '5', -type => 'value' );

  ## Selects the list item 'Red', using the default for -mode
  ## Remember that 'Red' is both the name and value for that item
  $jcb->setSelected( 'Red', -type => 'value' );

  ## Fails! There are no list item that begin with 'bl' 
  ## current selection unchanged
  $jcb->setSelected( 'bl', -mode => 'usecase' );

  ## Succeeds! Selects 'Black' - the first matching item
  $jcb->setSelected('bl', -mode => 'ignorecase' );
  
  MainLoop;</pre>

<a name="remove_elements"></a>
<br>
<h3>Removing items</h3>

<p class="pMargin">
Removing elements is even easier than adding them. There
are two methods provided to do this: <a href="../JComboBox.html#removeAllItems">
removeAllItems()</a> and <a href='../JComboBox.html#removeItemAt'>removeItemAt( index )</a>.
</p>
<p class="pMargin">To remove everything:</p>
<pre>
  $jcb->removeAllItems();</pre>

<br>
<p class="pMargin">
To remove a single item (the third in the list):
</p>
<pre>
  $jcb->removeItemAt( 2 );</pre>

<br>
<a name="additional"></a>
<h3>Additional Functionality</h3>

<a name="getitem"></a>
<h3>Getting list items</h3>
<p class="pMargin">
There are several methods that extracts information related to
invidual entries. Many of these are similar, and some are 
present only as a convenience. Among these are:
</p>

<ul>
   <li><a href='../JComboBox.html#getitemNameAt'>getItemNameAt</a>( <i>index</i> )
   <li><a href='../JCmoboBox.html#getItemValueAt'>getItemValueAt</a>( <i>index</i> )
</ul>
<p class="pMargin">
These two methods are nearly the same. <i>getItemNameAt</i> retrieves the 
displayed item or name at the given index, and <i>getItemValueAt</i>
returns the value associated with a list item ( or the item name, if the item
doesn't have a value ).
</p>

<ul>
   <li><a href='../JComboBox.html#getSelectedIndex'>getSelectedIndex</a>()</li>
   <li><a href='../JComboBox.html#getSelectedName'>getSelectedName</a>()</li>
   <li><a href='../JComboBox.html#getSelectedValue'>getSelectedValue</a>()</li>
</ul>
<p class="pMargin">
The first method of this bunch returns the index, of the selected item, and strictly
speaking, the second two methods are not really needed, because the getSelectedIndex
when used with <i>getItemNameAt</i> or <i>getItemValueAt</i> will do exactly 
what the <i>getSelectedName</i> and <i>getSelectedValue</i> methods do. They 
are only provided as a convenience.
</p> 

<a name="validation"></a>
<h3>Validation</h3>
<p class="pMargin">
Entry widgets can be validated. There are different validate modes
set using the <i>-validate</i> option, and custom validation
procedures can be created using the <i>-validatecommand</i>
option. Because JComboBox uses an entry widget for the 
<b>editable</b> mode, it also can use this approach to validation.
</p>

<p class="pMargin">
Unlike Entry, JComboBox has a built-in list of items that it can
use to perform validation. This can be useful for very long lists
of items. Long lists can be a hassle for a user interacting with
a user interface.  Although the <i>-maxrows</i> option can be set to
limit the size of the listbox, and prevent it from filling the screen
(and beyond), long lists can test the patience of someone who
needs to go through all the options -- especially someone who
knows that an item exists and just needs to get there.
</p>

<p class="pMargin">
For this reason, there are two additional values for <i>-validate</i>
that Entry does not have: <b>csmatch</b>, and <b>match</b>. Both
of these work nearly the same, the only difference is that csmatch is
case sensitive and match is not.  When -validate is set to one
of the 'match' methods, an additional set of bindings are set.
and functionality for the editable mode is enhanced slightly.
</p>

<p class="pMargin">
Every time a key is pressed, the current string in the Entry widget
will be compared to the name of each item until it finds a match.
If a match is found then the list will popup, and the matching listitem
will be highlighted. A user can choose  to continue typing the entry to 
get closer to the entry he wants, hit &lt;Return&gt; to select the item, or 
hit the &lt;Up&gt; or &lt;Down&gt; arrow keys to move the selection.
</p>

<p class="pMargin">
If no match is found, the letter the user just typed will not be invalid
and will not be allowed in the Entry.
</p>

<a name="listhighlight"></a>
<h3>List Highlighting</h3>
<p class="pMargin">
When the mouse pointer is above a menu list item, that item
is activated. That is, there is some indication that to show
that when the button is pressed, which item on the menu
will be selected. Combo boxes on Win32 platforms also
exhibit this behavior, and so does JComboBox, by default.
Other Perl/Tk combo box widgets do not, so this is an optional
behavior and it can be disabled by setting -listhighlight to
<b>0</b>.
</p>

<a name="related_docs"></a><h3>Related Documents</h3>
<p class="pMargin">
None at present.
</p>

<hr>
<Address><font size="-1">
This document was written by Rob Seegel on 20 Apr 2001
</font>
</Address>

</body>
</html>
